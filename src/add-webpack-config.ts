/* eslint-disable @typescript-eslint/no-explicit-any */
import type { NextConfig } from 'next';
import type * as NextServer from 'next/dist/server/config-shared';
import path from 'path';
import type * as Webpack from 'webpack';

import {
  regexIsLinariaGlobalCSSQuery,
  regexLinariaCSS,
  regexLinariaCSSQuery,
} from './loaders/consts';
import { LinariaLoaderOptions } from './loaders/webpack-transform-loader';
import { isCssLoader, isCssModule } from './utils/webpack-utils';

// Thanks https://github.com/Mistereo/next-linaria/blob/de4fd15269bd059e35797bb7250ce84cc8c5067c/index.js#L3 for the inspiration
/**
 * Modify the css loader config to support linaria global css and prevent
 * the default css-loader from generating classnames for linaria modules.
 */
function modifyCssLoaderConfig(rules: Webpack.RuleSetRule[]) {
  for (const rule of rules) {
    if (!rule) continue;
    if (isCssLoader(rule)) {
      if (isCssModule(rule)) {
        const nextGetLocalIdent = rule.options.modules.getLocalIdent;
        const nextMode = rule.options.modules.mode;

        // allow global css for *.linaria.global.css files
        rule.options.modules.mode = (path) => {
          const isGlobal = regexIsLinariaGlobalCSSQuery.test(path);
          if (isGlobal) {
            return 'local';
          }
          return typeof nextMode === 'function' ? nextMode(path) : nextMode;
        };

        // We don't want the default css-loader to generate classnames
        // for linaria modules, since those are generated by linaria.
        rule.options.modules.getLocalIdent = (
          context,
          _,
          exportName,
          ...rest
        ) => {
          if (regexLinariaCSSQuery.test(context.resourceQuery)) {
            return exportName;
          }
          return nextGetLocalIdent(context, _, exportName, ...rest);
        };
      }
    }
    if (typeof rule.use === 'object') {
      const useRules = rule.use as Webpack.RuleSetRule | Webpack.RuleSetRule[];
      modifyCssLoaderConfig(Array.isArray(useRules) ? useRules : [useRules]);
    }
    if (Array.isArray(rule.oneOf)) {
      modifyCssLoaderConfig(rule.oneOf as Webpack.RuleSetRule[]);
    }
  }
}

export type LinariaConfig = NextConfig & {
  /**
   * Linaria webpack loader options
   */
  linaria?: Omit<LinariaLoaderOptions, 'moduleStore' | 'name'> & {
    /**
     * Enables a quick syntax check to skip transform for files that don't contain Linaria code.
     * This can significantly improve performance for large projects.
     * @default true
     */
    fastCheck?: boolean;
    /**
     * Eanbles a prefixer for css rules.
     * @default true
     */
    prefixer?: boolean;
  };
};

export function addWebpackConfig({
  linaria = {},
  ...nextConfig
}: LinariaConfig) {
  const webpack = (
    config: Webpack.Configuration,
    options: NextServer.WebpackConfigContext,
  ) => {
    if (config.module?.rules && config.plugins) {
      modifyCssLoaderConfig(config.module.rules as Webpack.RuleSetRule[]);

      // Add css output loader with access to the module store
      // in order to set the correct dependencies
      config.module.rules.push({
        test: regexLinariaCSS,
        loader: path.resolve(__dirname, './loaders/webpack-output-css-loader'),
        options: {},
        exclude: /node_modules/,
      });

      // Add linaria loader to transform files
      const linariaLoaderOptions = {
        sourceMap: process.env.NODE_ENV !== 'production',
        displayName: process.env.NODE_ENV !== 'production',
        babelOptions: {
          presets: ['next/babel', '@wyw-in-js'],
        },
        ...linaria,
      };
      config.module.rules.push({
        test: /\.(tsx|ts|js|mjs|jsx)$/,
        exclude: /node_modules/,
        loader: path.resolve(__dirname, './loaders/webpack-transform-loader'),
        options: linariaLoaderOptions,
      });
    }

    if (typeof nextConfig.webpack === 'function') {
      return nextConfig.webpack(config, options);
    }
    return config;
  };

  return {
    ...nextConfig,
    webpack,
  };
}
